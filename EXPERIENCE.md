
# 프로젝트 경험 및 문제 해결 사례

---

### **1. 대규모 전동 킥보드 실시간 위치 추적 시스템 성능 최적화**

**[개요]**
수백 대의 전동 킥보드에서 전송되는 실시간 위치 데이터를 안정적으로 처리하고, 서버 과부하 및 데이터베이스 병목 현상을 해결하여 시스템의 전반적인 성능과 확장성을 개선했습니다.

**[문제 상황]**
- **서버 과부하:** 수백 대의 킥보드가 동시에 전송하는 대량의 위치 데이터로 인해 서버에 심각한 과부하가 발생했습니다.
- **DB 병목 현상:** 단일 MongoDB 컬렉션에 데이터가 누적되면서 문서 크기가 비대해져, 이로 인한 조회 및 저장 성능 저하가 발생했습니다.

**[해결 과정]**
- **Celery Multi-Worker 도입:** 단일 프로세스로 처리하던 데이터 수집 작업을 다수의 Worker가 병렬로 처리하는 Multi-Worker 구조로 전환하여 부하를 분산하고 처리 속도를 높였습니다.
- **Redis 캐싱 적용:** 반복적으로 요청되는 데이터나 자주 접근하는 킥보드 정보를 Redis에 캐싱하여 DB 조회 수를 줄이고, 응답 속도를 개선했습니다.
- **MongoDB 최적화:**
    - **인덱싱:** 데이터 조회 패턴을 분석하여 복합 인덱스를 생성하고, 쿼리 실행 계획을 최적화했습니다.
    - **시간 기반 버킷팅 (Time-based Bucketing):** 특정 시간 단위(예: 시간, 일)로 데이터를 그룹화하는 버킷팅 패턴을 적용하여 문서를 분리하고, 데이터 보관 및 아카이빙 효율을 높였습니다.

**[수행 결과]**
- **처리 속도 향상:** Celery Worker의 수평 확장을 통해 동시 요청 처리량을 대폭 증가시켰습니다.
- **응답 속도 개선:** Redis 캐싱 도입으로 반복 요청에 대한 응답 속도를 개선하고 DB 부하를 효과적으로 감소시켰습니다.
- **성능 및 효율성 확보:** MongoDB 쿼리 최적화를 통해 조회 성능을 향상시키고, 스토리지 효율성을 확보했습니다.
- **안정성 및 확장성 강화:** 시스템 아키텍처 개선을 통해 서비스의 전반적인 안정성과 확장성을 강화했습니다.

**[적용 기술]**
- **Backend:** Python, Celery, RabbitMQ
- **Database:** MongoDB, Redis
- **Infra:** AWS, Docker

---

### **2. 운영 자동화를 위한 아키텍처 개편 및 전용 API 시스템 구축**

**[개요]**
반복적인 운영 업무(메시지 발송, 스크립트 실행 등)를 자동화하고, 유지보수성과 확장성을 높이기 위해 기존 모놀리식 아키텍처를 마이크로서비스 아키텍처로 개편하고 전용 API 시스템을 구축했습니다.

**[문제 상황]**
- **유지보수 및 확장성 한계:** 운영팀의 주기적인 작업이 메인 애플리케이션에 통합되어 있어 코드의 복잡도가 높고, 기능 추가 및 수정 시 다른 서비스에 영향을 미칠 위험이 있었습니다.
- **분리된 시스템의 필요성:** 반복적인 백그라운드 작업을 메인 서비스와 독립적으로 처리할 수 있는 별도의 시스템 아키텍처가 필요했습니다.

**[해결 과정]**
- **마이크로서비스 설계:** 기능별 책임을 명확히 구분하여, 메시징, 스크립트 실행, 스케줄링 기능을 각각 독립적인 마이크로서비스로 분리하여 설계했습니다.
- **AWS ALB 도입:** 클라이언트의 요청을 성격에 맞게 각 마이크로서비스로 효율적으로 라우팅하도록 AWS ALB(Application Load Balancer)를 구성했습니다.
- **배포 자동화:** Docker를 통해 각 서비스를 컨테이너화하여 배포 환경을 표준화하고, CI/CD 파이프라인을 구축하여 배포 과정을 자동화했습니다.
- **레거시 코드 리팩토링:** 서비스별 단일 책임 원칙(SRP)을 적용하여 기존 레거시 코드에서 핵심 기능을 분리하고 재구성했습니다.

**[수행 결과]**
- **운영 효율성 증대:** 수동으로 처리하던 반복 작업을 자동화하여 처리 시간을 대폭 단축하고, 운영 비용 및 휴먼 에러 발생률을 감소시켰습니다.
- **배포 속도 및 품질 향상:** 마이크로서비스 단위의 독립적인 배포가 가능해져 전체 릴리즈 속도와 안정성이 향상되었습니다.
- **유지보수성 및 확장성 강화:** 서비스 간의 경계가 명확해져 코드베이스의 복잡도를 낮추고, 특정 기능의 확장이 용이한 구조를 마련했습니다.

**[적용 기술]**
- **Architecture:** Microservice Architecture (MSA)
- **Infra:** AWS (ALB, EC2, etc.), Docker
- **CI/CD:** AWS Codepipeline

---

### **3. 지식 공유 및 인수인계 효율화를 위한 개발 문서화 시스템 구축**

**[개요]**
개발팀 내 지식 공유를 활성화하고 신규 입사자의 온보딩 과정을 효율화하며, 반복되는 이슈에 체계적으로 대응하기 위해 개발 문서화 시스템을 구축하고 팀 문화로 정착시켰습니다.

**[문제 상황]**
- **정보 파편화:** 개발 관련 문서가 없거나, 있더라도 비일관적이고 파편화되어 있어 정보 파악에 많은 시간이 소요되었습니다.
- **인수인계 리스크:** 담당자 퇴사 또는 변경 시 관련 지식이 유실되어 프로젝트 연속성을 저해하는 리스크가 반복적으로 발생했습니다.
- **반복 이슈 관리 부재:** 과거에 발생했던 이슈와 해결 과정이 기록되지 않아, 유사한 문제가 발생했을 때 처음부터 다시 분석해야 하는 비효율이 있었습니다.

**[해결 과정]**
- **구조화된 문서 관리:** Confluence를 도입하여 서비스별, 환경별, 이슈별로 페이지 트리를 구조화하고, 누구나 쉽게 정보를 찾을 수 있도록 설계했습니다.
- **템플릿 도입:** '환경 설정 가이드', '장애 리포트', '기술 의사결정 회의록' 등 목적에 맞는 문서 템플릿을 마련하여 문서의 일관성과 가독성을 높였습니다.
- **문서화 문화 정착:** 주기적인 문서 리뷰 세션을 진행하고, 주요 기술 변경 사항이나 아키텍처 설계 내용은 반드시 문서로 남기도록 팀 내 규칙을 수립하여 생활화했습니다.

**[수행 결과]**
- **온보딩 기간 단축:** 체계적인 문서를 통해 신규 개발자의 온보딩 기간을 단축하고, 인수인계 과정의 효율성을 크게 향상시켰습니다.
- **이슈 대응 시간 단축:** 장애 리포트 및 해결 과정 기록을 통해 유사 이슈 발생 시 대응 시간을 단축하고, 반복적인 장애 발생률을 감소시켰습니다.
- **지식 공유 활성화:** 팀 내 지식 공유가 활성화되었고, 아키텍처나 기술 선택의 배경을 명확히 기록하여 프로젝트의 일관성 및 유지보수성을 강화했습니다.

**[적용 기술]**
- **Collaboration Tools:** Confluence, Jira
